//
// spwm_test
// This is a hybrid hardware/software PWM implementation. Since this msp430
// only has 2 TimerA capture/compare outputs, it must be expanded by software
// to drive 3 pwm outputs (for an RGB LED controller)
//
// A hardware timer is used to set a base clock by calling the ISR at a set
// interval. Within the ISR, a "software" timer is generated by counting up
// a variable and soft interrupts are implemented with a simple if statement
//
// This example fades each color in and out in R-G-B order and then repeats
//

#include <msp430.h>
#include <stdint.h>

// Determines LED brightness from 0 to 255 for each color { red, green, blue }
static uint8_t rgb[3] = {0, 0, 0};

int main(void)
{
  uint8_t mode = 1;
  uint8_t current_color = 0;

  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT

  // Setup oscillator for 16MHz operation
  BCSCTL1 = CALBC1_16MHZ;
  DCOCTL = CALDCO_16MHZ;

  // Wait for changes to take effect
  __delay_cycles(4000);

  // Configure ports -- switch inputs, LEDs, GDO0 to RX packet info from CCxxxx
  P2OUT |= (BIT0 | BIT1 | BIT2);
  P2DIR |= BIT0 | BIT1 | BIT2;

  // Setup timer A
  // SMCLK, up mode, enable interrupt
  TA0CTL = TASSEL_2 + MC_1 + TAIE + TACLR;
  TA0CCR0 = 512; // 512/16MHz = ~32us

  __bis_SR_register(GIE);       // Enter LPM3, enable interrupts

  // Fade the LED's on and off
  for(;;)
  {
    __delay_cycles(50000);
    if( mode )
    {
      if( ++rgb[current_color] == 255 )
      {
        mode = 0;
      }
    }
    else
    {
      if( --rgb[current_color] == 0 )
      {
        mode = 1;

        if( ++current_color == 3)
        {
          current_color = 0;
        }
      }
    }
  }

}

// Timer A isr
#pragma vector=TIMER0_A1_VECTOR
__interrupt void TA1_ISR (void)
{
  static uint8_t counter;

  // Increase virtual timer counter
  counter++;

  // Process red
  if ( counter >= rgb[0] )
  {
    P2OUT |= 0x01;
  }
  else
  {
    P2OUT &= ~0x01;
  }

  // Process green
  if ( counter >= rgb[1] )
  {
    P2OUT |= 0x02;
  }
  else
  {
    P2OUT &= ~0x02;
  }

  // process blue
  if ( counter >= rgb[2] )
  {
    P2OUT |= 0x04;
  }
  else
  {
    P2OUT &= ~0x04;
  }

  // Clear interrupt flag
  TA0IV &= ~TA0IV_TAIFG;

}
